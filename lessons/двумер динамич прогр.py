# Двумерное динамич программирование

# №1
# Король ходит по шахматной доске MxN вниз и вправо только!
# K количество способов достичь клетки (N, M)
# K(i, j) = K(i-1, j) + K(i, j-1) рекурретный случай
# K(1, 1) = K(1, M) = 1 по 1 строке проходим
# K(1, 1) = K(N, 1) = 1 по 1 столбцу проходит
# пусть будет 0 строка и 0 столбец
# K(1, 1) декларируем 1 - клетка-исключение
# Такая задача это C из n по k - сочетания без повторений

# №2
# Наибольшая общая подпослдовательность
# A(N), B(M) одномерные массивы чисел с разменостью в скобках
# Какая максимально возможная подпоследовательность С общая в А и В? в 
# в исходном порядке, но возможно не все
# [] пустая подп-ть точно подп-ть для любой последовательности
# F(i, j) = { 
# 1+F(i-1, j-1), a(i) == b(j)
# max(F(i, j-1), F(i-1, j), a(i) !== b(j)
#  }длина наиб возможной подпсл-ти 
# В случае a(i)=b(j) 


# F(0, j) = 0
# F(i, 0) = 0

def larget_common_subsequence(A, B):
    # на +1 больше, чтобы включить 0 строчку и 0 столбец
    F=[[0]*(len(B) +1) for i in range(len(A) + 1)]
    for i in range(1, len(A) + 1):
        for j in range(1, len(B) + 1):
            if A[i - 1] == B[j - 1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])
    return F[-1][-1]

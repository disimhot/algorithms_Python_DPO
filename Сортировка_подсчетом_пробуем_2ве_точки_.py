# Выведите все исходные точки в порядке возрастания их расстояний от начала координат.
# Создайте структуру Point и сохраните исходные данные в массиве структур Point.
# Программа получает на вход набор точек на плоскости. Сначала задано количество точек n,
# затем идет последовательность из n строк, каждая из которых содержит два числа: координаты точки.
# Величина n не превосходит 100, все исходные координаты – целые числа.
# Необходимо вывести все исходные точки в порядке возрастания их расстояний от начала координат.

# ВНИМАНИЕ, координаты 10^3 приближают нас к границам использования сортировки подсчетом,
# которая использует вспомогательный массив с кол-во ячеек = 10^3 * 10^3 * 100


fin = open('input.txt', 'r', encoding='utf8')
fout = open('output.txt', 'w', encoding='utf8')

# нужен будет корень
from math import sqrt
# список где будем хранить данные
myList = []

# точки , идея в том что мы дополнительно сохраняем расстояние float
# умноженое на 100, как Int , чтобы потом воспользоваться сортировкой подсчетом
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.big_leng = int(sqrt(x*x+y*y)*100)


len_list = int(fin.readline())
max_distance = 0
for i in range(len_list):
    p = list(map(int, fin.readline().split()))
    point = Point(p[0], p[1])
    # максимальная дистанция нам понадобиться для создания вспомогательного массива при
    # сортировке подсчетом, поэтому сразу ее найдем
    max_distance = max(max_distance, point.big_leng)
    myList.append(point)

# модифицированная сортировка подсчетом , возвращает отсортированный массив структур
# модификация заключается в том что мы работаем со свойством объекат Point.big_leng
def CountSort_FOR_POINT(myList, len_list, max_distance):
    L = len_list
    max_value = max_distance

    # Создаем вспомогательный список
    C = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in myList:
        C[p.big_leng] += 1

    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        C[i] = C[i-1] + C[i]

    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        C[myList[i].big_leng] -= 1
        B[C[myList[i].big_leng]] = myList[i]

    return B

new_list_point = CountSort_FOR_POINT(myList, len_list, max_distance)

for i in range(len_list):
    print(new_list_point[i].x, new_list_point[i].y, file=fout)

fin.close()
fout.close()
